# Лабораторная работа №3: Управление памятью и умные указатели

## Цель
Понять разницу между ручным управлением памятью и использованием умных указателей, научиться применять RAII.

## Задание 1: Утечка памяти
Пример `manual_leak.cpp` показывает, как можно забыть освободить память при использовании `new`.

Проверка утечки при написании `clang++ -fsanitize=address -g manual_leak.cpp && ./a.out`

## Задание 2: std::unique_ptr
Указатель `std::unique_ptr` сам освобождает память, исключая утечки. Класс `FileManager` демонстрирует применение RAII.

Проверка утечки при написании `clang++ -fsanitize=address -g unique_ptr_example.cpp && ./a.out`

## Задание 3: std::shared_ptr
Используется для совместного владения ресурсом. Счетчик ссылок автоматически освобождает ресурс при последнем владельце.

Проверка утечки при написании `clang++ -fsanitize=address -g shared_ptr_example.cpp && ./a.out`

## Задание 4: std::weak_ptr
Позволяет наблюдать за объектом, не увеличивая счетчик ссылок.

Проверка утечки при написании `clang++ -fsanitize=address -g weak_ptr_example.cpp && ./a.out`

## Сравнение указателей

| Тип             | Владение | Автоосвобождение | Совместное владение | Наблюдение |
|----------------|----------|------------------|----------------------|------------|
| unique_ptr      | Да       | Да               | Нет                  | Нет        |
| shared_ptr      | Да       | Да               | Да                   | Нет        |
| weak_ptr        | Нет      | Нет              | Да (через shared)    | Да         |
